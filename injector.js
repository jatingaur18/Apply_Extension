(function() {
  if (document.getElementById('job-autofill-container')) {
    const existingPanel = document.getElementById('job-autofill-container');
    existingPanel.style.display = existingPanel.style.display === 'none' ? 'flex' : 'none';
    return;
  }

  let currentScrapedData = null;
  let chatContext = [];
  const MAX_CONTEXT_MESSAGES = 20; 

  const container = document.createElement('div');
  container.id = 'job-autofill-container';
  document.body.appendChild(container);

  fetch(chrome.runtime.getURL('popup.html'))
    .then(response => response.text())
    .then(html => {
      container.innerHTML = html;
       
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = chrome.runtime.getURL('popup.css');
      document.head.appendChild(link);
       
      initializePanelLogic(container);
      makeDraggable(container);
    }).catch(err => console.error('Failed to load Job Autofill UI:', err));
     
  function initializePanelLogic(panel) {
    const tabButtons = panel.querySelectorAll('.tab-btn');
    const tabContents = panel.querySelectorAll('.tab-content');
     
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        tabButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        const tabId = button.getAttribute('data-tab');
        tabContents.forEach(content => {
          content.id === tabId ? content.classList.add('active') : content.classList.remove('active');
        });
      });
    });
     
    const autofillBtn = panel.querySelector('#autofill-btn');
    const autofillStatus = panel.querySelector('#autofill-status');
    const autofillDataContainer = panel.querySelector('#autofill-data');

    const originalAutofillClickHandler = async () => {
      console.log('Autofill button clicked');
      autofillStatus.textContent = 'Scanning page for forms...';
      autofillDataContainer.innerHTML = '';
       
      try {
        const formFields = await new Promise((resolve, reject) => {
          chrome.runtime.sendMessage({
            type: "execute-script",
            func: "scrapeFormFields"
          }, (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve(response);
            }
          });
        });

        console.log('Form fields found:', formFields);
        
        currentScrapedData = {
          timestamp: new Date().toISOString(),
          url: window.location.href,
          title: document.title,
          formFields: formFields
        };

        if (!formFields || formFields.length === 0) {
          autofillStatus.textContent = 'No form fields found on this page.';
          return;
        }

        autofillStatus.textContent = 'Asking Gemini to create a fill plan...';
        
        const profileResponse = await fetch(chrome.runtime.getURL('profile.json'));
        if (!profileResponse.ok) {
          throw new Error('Failed to load profile data');
        }
        const profileData = await profileResponse.json();
        console.log('Profile data loaded:', profileData);

        const actions = await new Promise((resolve, reject) => {
          chrome.runtime.sendMessage({ 
            type: 'get-form-mapping', 
            profileData, 
            formFields 
          }, (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else if (response && response.error) {
              reject(new Error(response.error));
            } else {
              resolve(response);
            }
          });
        });

        console.log('Actions received:', actions);

        if (!actions || actions.length === 0) {
          autofillStatus.textContent = 'No fill actions generated by AI.';
          return;
        }

        autofillStatus.textContent = 'Fill plan received. Click again to confirm and fill.';
        displayAutofillPlan(actions);

        autofillBtn.textContent = 'Confirm & Fill';
        autofillBtn.onclick = () => {
          autofillStatus.textContent = 'Executing fill plan...';
          chrome.runtime.sendMessage({
            type: "execute-script",
            func: "fillFormFields",
            args: [actions]
          }, (results) => {
            if (chrome.runtime.lastError) {
              autofillStatus.textContent = `Error: ${chrome.runtime.lastError.message}`;
              return;
            }
            autofillStatus.textContent = results || "Done!";
            setTimeout(() => {
              autofillBtn.textContent = 'Fill This Form';
              autofillBtn.onclick = originalAutofillClickHandler;
            }, 2000);
          });
        };

      } catch (error) {
        console.error("Autofill Error:", error);
        autofillStatus.textContent = `Error: ${error.message || 'An error occurred. Please refresh the page.'}`;
      }
    };
     
    autofillBtn.addEventListener('click', originalAutofillClickHandler);

    function displayAutofillPlan(actions) {
      autofillDataContainer.innerHTML = '';
      if (!actions || actions.length === 0) {
        autofillDataContainer.innerHTML = '<div class="data-item">No actions to display.</div>';
        return;
      }
      
      actions.forEach(action => {
        const item = document.createElement('div');
        item.className = 'data-item';
        item.innerHTML = `
          <strong>Field:</strong> ${action.identifier || 'Unknown'}<br>
          <strong>Action:</strong> ${action.action || 'Unknown'}<br>
          <strong>Value:</strong> <span>${action.value || 'Empty'}</span>
        `;
        autofillDataContainer.appendChild(item);
      });
    }
     
    // Enhanced Chat Tab Logic with Context Management
    const chatWindow = panel.querySelector('#chat-window');
    const chatInput = panel.querySelector('#chat-input');
    const chatSendBtn = panel.querySelector('#chat-send-btn');
    const includeDataCheckbox = panel.querySelector('#include-scraped-data');
    const scrapedDataInfo = panel.querySelector('#scraped-data-info');
    const clearChatBtn = panel.querySelector('#clear-chat-btn');
    const contextInfo = panel.querySelector('#context-info');
     
    function updateScrapedDataInfo() {
      if (currentScrapedData && currentScrapedData.formFields) {
        scrapedDataInfo.innerHTML = `
          <small>
            üìä <strong>Scraped Data Available:</strong><br>
            ‚Ä¢ ${currentScrapedData.formFields.length} form fields from ${currentScrapedData.title}<br>
            ‚Ä¢ Last updated: ${new Date(currentScrapedData.timestamp).toLocaleTimeString()}
          </small>
        `;
        scrapedDataInfo.style.display = 'block';
      } else {
        scrapedDataInfo.innerHTML = '<small>‚ÑπÔ∏è No form data scraped yet. Use "Fill This Form" first to collect data.</small>';
        scrapedDataInfo.style.display = 'block';
      }
    }

    function updateContextInfo() {
      if (contextInfo) {
        const contextLength = chatContext.length;
        if (contextLength > 0) {
          contextInfo.innerHTML = `<small>üí¨ Context: ${contextLength} messages stored</small>`;
          contextInfo.style.display = 'block';
        } else {
          contextInfo.style.display = 'none';
        }
      }
    }

    function clearChatContext() {
      chatContext = [];
      
      const messages = chatWindow.querySelectorAll('.chat-message');
      messages.forEach((msg, index) => {
        if (index > 0) {
          msg.remove();
        }
      });
      
      updateContextInfo();
    }

    function addToContext(message, role) {
      chatContext.push({
        role: role,
        content: message,
        timestamp: new Date().toISOString()
      });

      if (chatContext.length > MAX_CONTEXT_MESSAGES) {
        const recentMessages = chatContext.slice(-15);
        const importantEarlyMessages = chatContext.slice(0, 3);
        chatContext = [...importantEarlyMessages, ...recentMessages];
      }
      
      updateContextInfo();
    }

    updateScrapedDataInfo();
    updateContextInfo();

    const chatTabBtn = panel.querySelector('[data-tab="chat"]');
    if (chatTabBtn) {
      chatTabBtn.addEventListener('click', () => {
        updateScrapedDataInfo();
        updateContextInfo();
      });
    }

    if (clearChatBtn) {
      clearChatBtn.addEventListener('click', clearChatContext);
    }

    const handleChatSend = async () => {
      const query = chatInput.value.trim();
      if (!query) return;

      const includeScrapedData = includeDataCheckbox && includeDataCheckbox.checked;

      addChatMessage(query, 'user');
      addToContext(query, 'user');
      
      chatInput.value = '';
      chatInput.style.height = 'auto';
       
      try {
        const profileResponse = await fetch(chrome.runtime.getURL('profile.json'));
        const profileData = await profileResponse.json();

        const messageData = { 
          type: 'ask-gemini-with-context', 
          query, 
          profileData,
          chatContext: chatContext.slice() 
        };

        if (includeScrapedData && currentScrapedData) {
          messageData.scrapedData = currentScrapedData;
        }

        chrome.runtime.sendMessage(messageData, (response) => {
          if (chrome.runtime.lastError) {
            const errorMsg = `Error: ${chrome.runtime.lastError.message}. Please refresh the page.`;
            addChatMessage(errorMsg, 'bot');
            addToContext(errorMsg, 'assistant');
            return;
          }
          const answer = response?.answer || "Sorry, I couldn't get a response.";
          addChatMessage(answer, 'bot');
          addToContext(answer, 'assistant');
        });
      } catch (error) {
         const errorMsg = 'Could not fetch profile data. Please refresh the page.';
         addChatMessage(errorMsg, 'bot');
         addToContext(errorMsg, 'assistant');
         console.error("Chat Error:", error);
      }
    };

    chatSendBtn.addEventListener('click', handleChatSend);
    
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (e.shiftKey) {
          return;
        } else {
          e.preventDefault();
          handleChatSend();
        }
      }
    });

    chatInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 120) + 'px'; // Max height of ~4 lines
    });
    
    function addChatMessage(message, sender) {
      const messageEl = document.createElement('div');
      messageEl.className = `chat-message ${sender}`;
      
      if (message.includes('\n')) {
        messageEl.innerHTML = message.replace(/\n/g, '<br>');
      } else {
        messageEl.textContent = message;
      }
      
      chatWindow.appendChild(messageEl);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    setTimeout(() => {
      const helpMessage = 'üí° Features:\n‚Ä¢ Shift+Enter for new lines, Enter to send\n‚Ä¢ Check "Include scraped data" to analyze form fields\n‚Ä¢ Conversation context is maintained automatically\n‚Ä¢ Use "Clear Chat" to start fresh';
      addChatMessage(helpMessage, 'bot');
    }, 500);
  }

  function makeDraggable(element) {
    const header = element.querySelector('.drag-header');
    if (!header) return;

    let isDragging = false;
    let offsetX, offsetY;

    header.addEventListener('mousedown', (e) => {
      isDragging = true;
      offsetX = e.clientX - element.getBoundingClientRect().left;
      offsetY = e.clientY - element.getBoundingClientRect().top;
      element.style.cursor = 'grabbing';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      element.style.left = `${e.clientX - offsetX}px`;
      element.style.top = `${e.clientY - offsetY}px`;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      element.style.cursor = 'default';
    });
     
    const closeBtn = element.querySelector('.close-btn');
    if(closeBtn) {
      closeBtn.addEventListener('click', () => {
        element.style.display = 'none';
      });
    }
  }
})();